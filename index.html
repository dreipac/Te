<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500&display=swap" rel="stylesheet">

<title>Heart Particles</title>
<style>
:root{
  --bg1:#1a0004;
  --bg2:#2a0010;
  --bg3:#4d001d;
  --heart:#ff4d6d; /* warmes, weiches Rotrosa */
}

  html,body{
    height:100%;
    margin:0;
    background-color:radial-gradient(1200px 800px at 50% 35%, var(--bg3), var(--bg2) 50%, var(--bg1) 100%);
    background: radial-gradient(1200px 800px at 50% 35%, var(--bg3), var(--bg2) 50%, var(--bg1) 100%);
    overflow:hidden;
color:#ffe0e4;

    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  /* Canvas layer stack */
  .stage{
    position:fixed; 
    inset:0; display:grid; 
    place-items:center;
  }
  canvas{
    position:absolute; inset:0;
    width:100%; height:100%;
    display:block;
  }

  /* Text-Layer hebt sich mit Glow besser ab */
#text { filter: none; }


  /* Subtle credit / instruction (can be removed) */
  .ui{
    position:fixed; left:50%; bottom:24px; transform:translateX(-50%);
    font-size:12px; letter-spacing:.08em; opacity:.55; user-select:none;
  }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="bg"></canvas>     <!-- Hintergrund-Bokeh -->
    <canvas id="heart"></canvas>  <!-- Großes Herz -->
    <canvas id="text"></canvas>   <!-- Text aus Herzpunkten -->
  </div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // ====== Canvas Setup ======
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  const canvases = {
    bg: document.getElementById('bg'),
    heart: document.getElementById('heart'),
    text: document.getElementById('text')
  };
  const ctx = {
    bg: canvases.bg.getContext('2d'),
    heart: canvases.heart.getContext('2d'),
    text: canvases.text.getContext('2d')
  };

  // ====== Globale Geometrie ======
  const PATH_SAMPLES = 1400;
  let leftArc = [], rightArc = [];
  let centerX = 0, centerY = 0, centerScale = 1;
  let heartBottomY = 0; // <- NEU: Y-Position der Herzspitze (für Text-Placement)


  // ====== Utils ======
  function rand(a,b){ return a + Math.random()*(b-a); }
  function noise1D(x){ const n = Math.sin(x*12.9898)*43758.5453; return n - Math.floor(n); }

  // kleines Herz
  function drawTinyHeart(context, x, y, size, fill, alpha=1, glow=8){
    context.save();
    context.translate(x, y);
    context.scale(size, size);
    context.globalAlpha = alpha;
    context.fillStyle = fill;
    context.shadowBlur = glow;
    context.shadowColor = fill;
    context.beginPath();
    context.moveTo(0, 0.35);
    context.bezierCurveTo(0, -0.15, -0.55, -0.1, -0.55, 0.2);
    context.bezierCurveTo(-0.55, 0.5, -0.2, 0.65, 0, 0.85);
    context.bezierCurveTo(0.2, 0.65, 0.55, 0.5, 0.55, 0.2);
    context.bezierCurveTo(0.55, -0.1, 0, -0.15, 0, 0.35);
    context.closePath();
    context.fill();
    context.restore();
  }

  // Herzkurve
  function heartPoint(t){
    const x = 16*Math.pow(Math.sin(t),3);
    const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
    return { x: x/18, y: -y/18 }; // y nach oben positiv
  }

  // ====== Touch Effects (NEU) ======
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function clientToCanvas(clientX, clientY){
  // CSS-Size = Fenstergröße; wir skalieren mit DPR auf Canvas-Pixel
  const rect = canvases.heart.getBoundingClientRect();
  const x = (clientX - rect.left) * DPR;
  const y = (clientY - rect.top)  * DPR;
  return {x,y};
}

const touchBursts = [];     // kurzlebige „Puff“-Partikel beim Tippen
const touchTrails = [];     // Mini-Herzen entlang der Finger-Spur
const pointerStates = new Map(); // per Pointer-ID: {lastX,lastY,lastT}

function spawnBurst(x, y, intensity = 1){
  const n = Math.floor(18*intensity + Math.random()*14);
  for(let i=0;i<n;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = 90 + Math.random()*220;
    touchBursts.push({
      x, y,
      vx: Math.cos(ang)*spd,
      vy: Math.sin(ang)*spd*0.7 - 60, // leichter „Schwung“ nach oben
      life: 0.85 + Math.random()*0.6,
      age: 0,
      size: 6*DPR + Math.random()*8*DPR,
      spin: (Math.random()*2-1)*2.2,
      color: Math.random() < 0.5 ? '#ff7fbd' : '#ff8ecb',
      glow: 12 + Math.random()*16
    });
  }
}

function spawnTrailSegment(x0, y0, x1, y1){
  const dx = x1-x0, dy = y1-y0;
  const dist = Math.hypot(dx,dy);
  const step = 18*DPR; // Abstand der Spur-Herzen
  const steps = Math.max(1, Math.floor(dist/step));
  for(let i=0;i<steps;i++){
    const t = i/steps;
    const x = x0 + dx*t + rand(-2,2)*DPR*0.6;
    const y = y0 + dy*t + rand(-2,2)*DPR*0.6;
    touchTrails.push({
      x, y,
      life: 0.9, age: 0,
      size: 4.5*DPR + Math.random()*3*DPR,
      color: Math.random()<0.7 ? '#ff7fbd' : '#ffc4de',
      glow: 10 + Math.random()*12
    });
  }
}

function updateAndDrawTouches(dt){
  const c = ctx.heart;

  // Bursts
  for(let i=touchBursts.length-1;i>=0;i--){
    const p = touchBursts[i];
    p.age += dt;
    if(p.age >= p.life){ touchBursts.splice(i,1); continue; }

    // Bewegung: sanfter Luftwiderstand + minimale „Schwerkraft“ nach oben
    p.vx *= 0.985; 
    p.vy = p.vy*0.985 - 12*dt;

    p.x += p.vx*dt;
    p.y += p.vy*dt;

    const a = clamp(1 - p.age/p.life, 0, 1);
    drawTinyHeart(c, p.x, p.y, p.size, p.color, a, p.glow);
  }

  // Trails
  for(let i=touchTrails.length-1;i>=0;i--){
    const p = touchTrails[i];
    p.age += dt;
    if(p.age >= p.life){ touchTrails.splice(i,1); continue; }
    const a = clamp(1 - p.age/p.life, 0, 1);
    drawTinyHeart(c, p.x, p.y, p.size, p.color, a, p.glow);
  }
}


  // ====== Pfade neu aufbauen ======
  function rebuildPaths(){
    const w = canvases.heart.width, h = canvases.heart.height;
    centerX = w * 0.5;
    centerY = h * 0.43;
    centerScale = Math.min(w,h) * 0.5;

    const pts = [];
    for (let i=0;i<PATH_SAMPLES;i++){
      const t = -Math.PI + i*(2*Math.PI/(PATH_SAMPLES-1));
      const p = heartPoint(t);
      pts.push({t, x: centerX + p.x*centerScale, y: centerY + p.y*centerScale});
    }

    // Index für Kerbe oben (max y) und Spitze unten (min y)
    let iTop=0, iBottom=0;
    for (let i=1;i<pts.length;i++){
      if (pts[i].y > pts[iTop].y) iTop = i;
      if (pts[i].y < pts[iBottom].y) iBottom = i;
    }
      heartBottomY = pts[iTop].y;

    // Rechtsbogen: im Uhrzeigersinn von oben zur Spitze
    rightArc = [];
    for (let i=iTop; i!==iBottom; i=(i+1)%pts.length) rightArc.push(pts[i]);
    rightArc.push(pts[iBottom]);

    // Linksbogen: gegen den Uhrzeigersinn von oben zur Spitze
    leftArc = [];
    for (let i=iTop; i!==iBottom; i=(i-1+pts.length)%pts.length) leftArc.push(pts[i]);
    leftArc.push(pts[iBottom]);
  }

  // ====== Resize ======
  function resize() {
    const w = window.innerWidth || document.documentElement.clientWidth;
    const h = window.innerHeight || document.documentElement.clientHeight;
    [canvases.bg, canvases.heart, canvases.text].forEach((c) => {
      c.width  = Math.floor(w*DPR);
      c.height = Math.floor(h*DPR);
      c.style.width  = w+'px';
      c.style.height = h+'px';
    });
    rebuildPaths();
    renderText();
  }
  window.addEventListener('resize', resize);

// ====== Touch/Pointer Events (NEU) ======
const inputTarget = canvases.text; // oberste Ebene – fängt die Interaktion ab

inputTarget.addEventListener('pointerdown', (e) => {
  const {x,y} = clientToCanvas(e.clientX, e.clientY);
  spawnBurst(x, y, 1);
  pointerStates.set(e.pointerId, { lastX:x, lastY:y, lastT: performance.now() });
  try { inputTarget.setPointerCapture(e.pointerId); } catch {}
}, {passive:false});

inputTarget.addEventListener('pointermove', (e) => {
  if(!pointerStates.has(e.pointerId)) return;
  const st = pointerStates.get(e.pointerId);
  const now = performance.now();
  const {x,y} = clientToCanvas(e.clientX, e.clientY);
  // Rate-Limit für Trail (ca. alle ~22ms)
  if(now - st.lastT > 22){
    spawnTrailSegment(st.lastX, st.lastY, x, y);
    st.lastX = x; st.lastY = y; st.lastT = now;
  }
  e.preventDefault(); // verhindert ungewolltes Scrollen beim Ziehen
}, {passive:false});

function endPointer(e){
  if(pointerStates.has(e.pointerId)){
    pointerStates.delete(e.pointerId);
    try { inputTarget.releasePointerCapture(e.pointerId); } catch {}
  }
}
inputTarget.addEventListener('pointerup', endPointer, {passive:true});
inputTarget.addEventListener('pointercancel', endPointer, {passive:true});

  // ====== Hintergrund ======
  const BG_COUNT = 80;
  const bgHearts = Array.from({length:BG_COUNT}, () => ({
    x: Math.random(), y: Math.random(),
    s: 0.5 + Math.random()*1.8,
    a: 0.15 + Math.random()*0.4,
    speed: 0.005 + Math.random()*0.02,
    drift: (Math.random()*2-1)*0.0007
  }));
  function renderBG(){
    const c = ctx.bg, w = canvases.bg.width, h = canvases.bg.height;
    c.clearRect(0,0,w,h);
    for (const p of bgHearts){
      p.y -= p.speed;
      p.x += p.drift;
      if (p.y < -0.05) { p.y = 1.05; p.x = (p.x+Math.random()*0.2)%1; }
      if (p.x < -0.05) p.x = 1.05;
      if (p.x >  1.05) p.x = -0.05;
      drawTinyHeart(c, p.x*w, p.y*h, 6*DPR*p.s, '#ff7fbd', p.a, 10);
    }
  }

  // ====== Flow-Emitter (wie index.html – stabile Lanes) ======
const LANES = [-1, 0, 1];            // drei Reihen
const LANE_SPACING = 2.2 * DPR;      // Abstand von der Randlinie (in px)
const FLOW_RATE = 46;                 // Partikel/Sek
const SPEED_MIN = 110, SPEED_MAX = 220; // ruhiger
const particles = [];
let spawnCarry = 0;
const baseHue = 330;

function spawn(dt){
  const want = FLOW_RATE*dt + spawnCarry;
  let n = Math.floor(want);
  spawnCarry = want - n;

  for(let i=0; i<n; i++){
    const side = Math.random()<0.5 ? 'left' : 'right';
    const arc = side==='left' ? leftArc : rightArc;
    if(arc.length < 2) break;

    const lane = LANES[Math.floor(Math.random()*LANES.length)]; // -1, 0, 1
    const hue = baseHue + (Math.random()*6 - 3);

    particles.push({
      side, idx:0, s:0, lane,
      speed: SPEED_MIN + Math.random()*(SPEED_MAX - SPEED_MIN),
      size: 4.4 + Math.random()*3.2,
      alpha: 0,
      color: `hsl(${hue},100%,76%)`,
      glow: 14 + Math.random()*16
    });
  }
}

function advanceAndDraw(dt){
  const c = ctx.heart, w = canvases.heart.width, h = canvases.heart.height;
  c.clearRect(0,0,w,h);

  for(let i=particles.length-1; i>=0; i--){
    const p = particles[i];
    const arc = p.side==='left' ? leftArc : rightArc;
    if(arc.length < 2){ particles.splice(i,1); continue; }

    // Wegstrecke voran
    p.s += p.speed*dt;
    while(p.idx < arc.length-2){
      const ax = arc[p.idx].x, ay = arc[p.idx].y;
      const bx = arc[p.idx+1].x, by = arc[p.idx+1].y;
      const seg = Math.hypot(bx-ax, by-ay);
      if(p.s > seg){ p.s -= seg; p.idx++; }
      else break;
    }

    // Ein-/Ausblenden
    const atEnd = p.idx >= arc.length-2;
    if(atEnd && p.s>0){
      p.alpha -= 2.2*dt;
      if(p.alpha <= 0){ particles.splice(i,1); continue; }
    }else{
      p.alpha = Math.min(1, p.alpha + 2.4*dt);
    }

    // Position auf Segment
    const A = arc[p.idx], B = arc[p.idx+1];
    const segLen = Math.hypot(B.x-A.x, B.y-A.y) || 1;
    const u = Math.max(0, Math.min(1, p.s/segLen));
    let x = A.x + (B.x-A.x)*u;
    let y = A.y + (B.y-A.y)*u;

    // Normale + fester Lane-Versatz => stabile Reihen (kein Wobble)
    const nx = (A.y - B.y)/segLen, ny = (B.x - A.x)/segLen;
    x += nx * (p.lane * LANE_SPACING);
    y += ny * (p.lane * LANE_SPACING);

    // ganz leichter, glatter Hauch (zitternfrei)
    x += Math.sin((p.idx+u)*0.02) * 0.4 * DPR;
    y += Math.cos((p.idx+u)*0.02) * 0.4 * DPR;

    // gleiche Herzchen wie im Rest der Datei
    drawTinyHeart(c, x, y, (30*p.size*DPR)/24, p.color, Math.max(0, Math.min(1, p.alpha)), p.glow);
  }
}


    // ====== Text ======
  const TEXT = "TE DUA ZEMRA JEM";

  function renderText(tms = 0){
    const c = ctx.text, w = canvases.text.width, h = canvases.text.height;
    c.clearRect(0, 0, w, h);

    // responsive Schriftgröße (gut lesbar, aber nicht zu aufdringlich)
    const base = Math.min(w, h);
    const fontPx = Math.max(24 * DPR, Math.min(base * 0.065, 58 * DPR));

    c.save();
    c.textAlign = "center";
    c.textBaseline = "middle";
    c.font = `600 ${fontPx}px "Dancing Script", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial`;

    // Position etwas unterhalb der Herzspitze
    const cx = w * 0.5;
    const margin = Math.max(28 * DPR, h * 0.05);
    const y = Math.min(h - margin, heartBottomY + Math.max(70 * DPR, h * 0.1));

    // sanfter, dunklerer Verlauf – passt besser ins Violett
    const grad = c.createLinearGradient(cx - base * 0.25, 0, cx + base * 0.25, 0);
    grad.addColorStop(0.0, "#d26aa0");
    grad.addColorStop(0.5, "#b64c88");
    grad.addColorStop(1.0, "#d26aa0");

    // dezenter Glow
    c.shadowBlur = 10 * DPR;
    c.shadowColor = "rgba(255, 100, 170, 0.5)";
    c.fillStyle = grad;
    c.fillText(TEXT, cx, y);

    // leichte Kontur für bessere Lesbarkeit
    c.lineWidth = Math.max(1 * DPR, fontPx * 0.03);
    c.strokeStyle = "rgba(255, 200, 230, 0.3)";
    c.strokeText(TEXT, cx, y);

    // optional: sanfter Schimmer, aber zurückhaltend
    const t = (tms * 0.001) % 1;
    const hiStart = Math.max(0, Math.min(1, t));
    const hiEnd = Math.min(1, hiStart + 0.10);
    const hiGrad = c.createLinearGradient(cx - base * 0.25, 0, cx + base * 0.25, 0);
    hiGrad.addColorStop(0, "rgba(255,255,255,0)");
    hiGrad.addColorStop(hiStart, "rgba(255,255,255,0)");
    hiGrad.addColorStop((hiStart + hiEnd) / 2, "rgba(255,255,255,0.25)");
    hiGrad.addColorStop(hiEnd, "rgba(255,255,255,0)");
    hiGrad.addColorStop(1, "rgba(255,255,255,0)");

    c.globalCompositeOperation = "lighter";
    c.shadowBlur = 8 * DPR;
    c.shadowColor = "rgba(255,255,255,0.3)";
    c.fillStyle = hiGrad;
    c.fillText(TEXT, cx, y);

    c.restore();
  }




  // ====== Loop ======
  let lastTs = performance.now();
  function loop(ts){
    const dt = Math.min(0.05, (ts - lastTs)/1000);
    renderBG();
    spawn(dt);
    advanceAndDraw(dt);
    updateAndDrawTouches(dt); // <- NEU: Touch-Effekte über dem Herz-Emitter

    renderText(ts); // <- NEU: Text mit animiertem Shimmer
    lastTs = ts;
    requestAnimationFrame(loop);
  }


  // Start
  resize();
  requestAnimationFrame(loop);
});
</script>



</body>
</html>
